# üöÄ Phase 1: Workout Sharing Backend Implementation Plan

**Approach:** Copy-on-Share (Option B)  
**Timeline:** 2-3 weeks  
**Complexity:** Low-Medium  
**Status:** Ready for Implementation

---

## üìã Overview

This plan implements a simple, robust workout sharing system using a **copy-on-share** approach. When a user shares a workout, the entire workout document is copied to a shared collection. No live updates or complex linking - just clean, simple sharing.

### Key Principles
- ‚úÖ **Copy entire workout** on share (no references)
- ‚úÖ **Static snapshots** - shared workouts don't update when original changes
- ‚úÖ **Simple security** - straightforward Firestore rules
- ‚úÖ **Track engagement** - views and saves
- ‚úÖ **Optional attribution** - user chooses to show name or stay anonymous

---

## üóÇÔ∏è Database Architecture

### Confirmed Existing Structure
```
users/{userId}/workouts/{workoutId}/
  ‚îú‚îÄ‚îÄ id: "workout-542be09e"
  ‚îú‚îÄ‚îÄ name: "Push Day"
  ‚îú‚îÄ‚îÄ description: ""
  ‚îú‚îÄ‚îÄ exercise_groups: [...]
  ‚îú‚îÄ‚îÄ bonus_exercises: [...]
  ‚îú‚îÄ‚îÄ tags: []                    ‚úÖ Already exists!
  ‚îú‚îÄ‚îÄ is_template: true
  ‚îú‚îÄ‚îÄ created_date: timestamp
  ‚îú‚îÄ‚îÄ modified_date: timestamp
  ‚îú‚îÄ‚îÄ version: 30
  ‚îî‚îÄ‚îÄ sync_status: "synced"
```

### New Collections to Create

#### 1. `public_workouts/` (Root-level collection)
```javascript
{
  // Document ID: auto-generated by Firestore
  
  // Full workout snapshot
  workout_data: {
    name: "Push Day",
    description: "Chest, shoulders, triceps",
    exercise_groups: [...],      // Full copy
    bonus_exercises: [...],      // Full copy
    tags: ["push", "hypertrophy"] // Copied from original
  },
  
  // Creator info
  creator_id: "userId",
  creator_name: "John Doe" | null,  // null = anonymous
  source_workout_id: "workout-542be09e",
  
  // Metadata
  created_at: SERVER_TIMESTAMP,
  is_moderated: false,           // Admin flag for content moderation
  
  // Engagement stats
  stats: {
    view_count: 0,
    save_count: 0
  }
}
```

#### 2. `private_shares/` (Root-level collection)
```javascript
{
  // Document ID: share token (e.g., "abc123xyz")
  
  // Full workout snapshot
  workout_data: {
    name: "Push Day",
    description: "Chest, shoulders, triceps",
    exercise_groups: [...],
    bonus_exercises: [...],
    tags: ["push"]
  },
  
  // Creator info
  creator_id: "userId",
  creator_name: "John Doe" | null,
  
  // Metadata
  created_at: SERVER_TIMESTAMP,
  expires_at: timestamp | null,  // Optional expiration
  view_count: 0
}
```

---

## üìÅ Files to Create/Modify

### New Files
1. **`backend/services/sharing_service.py`** - Core sharing logic
2. **`backend/api/sharing.py`** - API endpoints
3. **`firestore.indexes.json`** - Firestore indexes configuration

### Files to Modify
1. **`backend/models.py`** - Add sharing data models
2. **`backend/main.py`** - Register sharing router

### Manual Configuration
1. **Firebase Console** - Add security rules
2. **Firebase Console** - Deploy indexes

---

## üîß Implementation Steps

See detailed implementation in the following sections:
- [Step 1: Data Models](#step-1-data-models)
- [Step 2: Sharing Service](#step-2-sharing-service)
- [Step 3: API Endpoints](#step-3-api-endpoints)
- [Step 4: Register Router](#step-4-register-router)
- [Step 5: Firestore Indexes](#step-5-firestore-indexes)
- [Step 6: Security Rules](#step-6-security-rules)
- [Step 7: Testing](#step-7-testing)

---

## Step 1: Data Models

**File:** `backend/models.py`

Add these models at the end of the file:

```python
# ============================================================================
# Workout Sharing Models (Phase 1 - Copy-on-Share)
# ============================================================================

class SharedWorkoutStats(BaseModel):
    """Statistics for shared workouts"""
    view_count: int = Field(default=0, ge=0)
    save_count: int = Field(default=0, ge=0)

class PublicWorkout(BaseModel):
    """Public shared workout"""
    id: str = Field(default_factory=lambda: f"public-{uuid4().hex[:8]}")
    workout_data: Dict[str, Any] = Field(..., description="Full workout snapshot")
    creator_id: str = Field(..., description="User ID of creator")
    creator_name: Optional[str] = Field(None, description="Display name (null = anonymous)")
    source_workout_id: str = Field(..., description="Original workout ID")
    created_at: datetime = Field(default_factory=datetime.now)
    is_moderated: bool = Field(default=False, description="Admin moderation flag")
    stats: SharedWorkoutStats = Field(default_factory=SharedWorkoutStats)

class PrivateShare(BaseModel):
    """Private workout share with token"""
    token: str = Field(..., description="Share token (document ID)")
    workout_data: Dict[str, Any] = Field(..., description="Full workout snapshot")
    creator_id: str = Field(..., description="User ID of creator")
    creator_name: Optional[str] = Field(None, description="Display name (null = anonymous)")
    created_at: datetime = Field(default_factory=datetime.now)
    expires_at: Optional[datetime] = Field(None, description="Optional expiration")
    view_count: int = Field(default=0, ge=0)

# Request Models
class ShareWorkoutPublicRequest(BaseModel):
    """Request to share workout publicly"""
    workout_id: str = Field(..., description="ID of workout to share")
    show_creator_name: bool = Field(default=True, description="Show creator attribution")

class ShareWorkoutPrivateRequest(BaseModel):
    """Request to create private share"""
    workout_id: str = Field(..., description="ID of workout to share")
    show_creator_name: bool = Field(default=True)
    expires_in_days: Optional[int] = Field(None, ge=1, le=365, description="Expiration in days")

class SavePublicWorkoutRequest(BaseModel):
    """Request to save public workout to user's library"""
    custom_name: Optional[str] = Field(None, description="Optional custom name")

# Response Models
class PublicWorkoutListResponse(BaseModel):
    """Response for browsing public workouts"""
    workouts: List[PublicWorkout]
    total_count: int
    page: int = 1
    page_size: int = 20

class ShareTokenResponse(BaseModel):
    """Response after creating private share"""
    token: str
    share_url: str
    expires_at: Optional[datetime] = None
```

---

## Step 2: Sharing Service

**Create:** `backend/services/sharing_service.py`

This file contains the core sharing logic. Due to length, see the complete implementation in:
[`WORKOUT_SHARING_SERVICE_IMPLEMENTATION.md`](WORKOUT_SHARING_SERVICE_IMPLEMENTATION.md)

Key methods:
- `share_workout_publicly()` - Copy workout to public_workouts
- `share_workout_privately()` - Create private share with token
- `get_public_workouts()` - Browse with filtering/sorting
- `save_public_workout()` - Copy to user's library
- `increment_view_count()` - Track engagement

---

## Step 3: API Endpoints

**Create:** `backend/api/sharing.py`

```python
"""
Workout Sharing API Endpoints
"""

from fastapi import APIRouter, Depends, HTTPException, Query
from typing import List, Optional
import logging

from ..models import (
    PublicWorkout, PrivateShare, WorkoutTemplate,
    ShareWorkoutPublicRequest, ShareWorkoutPrivateRequest,
    SavePublicWorkoutRequest, PublicWorkoutListResponse,
    ShareTokenResponse
)
from ..services.sharing_service import sharing_service
from ..services.firestore_data_service import firestore_data_service
from ..middleware.auth import get_current_user_optional, extract_user_id

router = APIRouter(prefix="/api/v3/sharing", tags=["Sharing"])
logger = logging.getLogger(__name__)

# PUBLIC SHARING
@router.post("/share-public", response_model=PublicWorkout)
async def share_workout_publicly(
    request: ShareWorkoutPublicRequest,
    current_user: Optional[dict] = Depends(get_current_user_optional)
):
    """Share a workout publicly"""
    user_id = extract_user_id(current_user)
    if not user_id:
        raise HTTPException(status_code=401, detail="Authentication required")
    
    workout = await firestore_data_service.get_workout(user_id, request.workout_id)
    if not workout:
        raise HTTPException(status_code=404, detail="Workout not found")
    
    public_workout = await sharing_service.share_workout_publicly(
        user_id=user_id,
        workout=workout,
        show_creator_name=request.show_creator_name
    )
    
    if not public_workout:
        raise HTTPException(status_code=500, detail="Failed to share workout")
    
    return public_workout

@router.get("/public-workouts", response_model=PublicWorkoutListResponse)
async def browse_public_workouts(
    page: int = Query(1, ge=1),
    page_size: int = Query(20, ge=1, le=100),
    tags: Optional[List[str]] = Query(None),
    sort_by: str = Query("created_at")
):
    """Browse public workouts"""
    result = await sharing_service.get_public_workouts(
        page=page,
        page_size=page_size,
        tags=tags,
        sort_by=sort_by
    )
    return PublicWorkoutListResponse(**result)

@router.get("/public-workouts/{public_workout_id}", response_model=PublicWorkout)
async def get_public_workout(public_workout_id: str):
    """Get specific public workout (increments view count)"""
    workout = await sharing_service.get_public_workout(public_workout_id)
    if not workout:
        raise HTTPException(status_code=404, detail="Public workout not found")
    return workout

@router.post("/public-workouts/{public_workout_id}/save", response_model=WorkoutTemplate)
async def save_public_workout(
    public_workout_id: str,
    request: SavePublicWorkoutRequest,
    current_user: Optional[dict] = Depends(get_current_user_optional)
):
    """Save public workout to user's library"""
    user_id = extract_user_id(current_user)
    if not user_id:
        raise HTTPException(status_code=401, detail="Authentication required")
    
    saved_workout = await sharing_service.save_public_workout(
        user_id=user_id,
        public_workout_id=public_workout_id,
        custom_name=request.custom_name
    )
    
    if not saved_workout:
        raise HTTPException(status_code=500, detail="Failed to save workout")
    
    return saved_workout

# PRIVATE SHARING
@router.post("/share-private", response_model=ShareTokenResponse)
async def share_workout_privately(
    request: ShareWorkoutPrivateRequest,
    current_user: Optional[dict] = Depends(get_current_user_optional)
):
    """Create private share with token"""
    user_id = extract_user_id(current_user)
    if not user_id:
        raise HTTPException(status_code=401, detail="Authentication required")
    
    workout = await firestore_data_service.get_workout(user_id, request.workout_id)
    if not workout:
        raise HTTPException(status_code=404, detail="Workout not found")
    
    share_result = await sharing_service.share_workout_privately(
        user_id=user_id,
        workout=workout,
        show_creator_name=request.show_creator_name,
        expires_in_days=request.expires_in_days
    )
    
    if not share_result:
        raise HTTPException(status_code=500, detail="Failed to create share")
    
    return ShareTokenResponse(**share_result)

@router.get("/share/{token}", response_model=PrivateShare)
async def get_private_share(token: str):
    """Get private share by token"""
    share = await sharing_service.get_private_share(token)
    if not share:
        raise HTTPException(status_code=404, detail="Share not found or expired")
    return share

@router.post("/share/{token}/save", response_model=WorkoutTemplate)
async def save_private_share(
    token: str,
    request: SavePublicWorkoutRequest,
    current_user: Optional[dict] = Depends(get_current_user_optional)
):
    """Save private share to user's library"""
    user_id = extract_user_id(current_user)
    if not user_id:
        raise HTTPException(status_code=401, detail="Authentication required")
    
    saved_workout = await sharing_service.save_private_share(
        user_id=user_id,
        token=token,
        custom_name=request.custom_name
    )
    
    if not saved_workout:
        raise HTTPException(status_code=500, detail="Failed to save workout")
    
    return saved_workout

@router.delete("/share/{token}")
async def delete_private_share(
    token: str,
    current_user: Optional[dict] = Depends(get_current_user_optional)
):
    """Delete private share (creator only)"""
    user_id = extract_user_id(current_user)
    if not user_id:
        raise HTTPException(status_code=401, detail="Authentication required")
    
    success = await sharing_service.delete_private_share(user_id, token)
    if not success:
        raise HTTPException(status_code=404, detail="Share not found or unauthorized")
    
    return {"message": "Share deleted successfully"}
```

---

## Step 4: Register Router

**Modify:** `backend/main.py`

Add the sharing router:

```python
# Add to imports at top
from .api import health, documents, workouts, programs, exercises, favorites, auth, data, migration, workout_sessions, sharing

# Add after other routers (around line 53)
app.include_router(sharing.router)  # Workout sharing endpoints

# Update logger message
logger.info("‚úÖ All routers included successfully (13 routers total)")
```

---

## Step 5: Firestore Indexes

**Create:** `firestore.indexes.json`

```json
{
  "indexes": [
    {
      "collectionGroup": "public_workouts",
      "queryScope": "COLLECTION",
      "fields": [
        {
          "fieldPath": "is_moderated",
          "order": "ASCENDING"
        },
        {
          "fieldPath": "created_at",
          "order": "DESCENDING"
        }
      ]
    },
    {
      "collectionGroup": "public_workouts",
      "queryScope": "COLLECTION",
      "fields": [
        {
          "fieldPath": "is_moderated",
          "order": "ASCENDING"
        },
        {
          "fieldPath": "stats.view_count",
          "order": "DESCENDING"
        }
      ]
    },
    {
      "collectionGroup": "public_workouts",
      "queryScope": "COLLECTION",
      "fields": [
        {
          "fieldPath": "is_moderated",
          "order": "ASCENDING"
        },
        {
          "fieldPath": "stats.save_count",
          "order": "DESCENDING"
        }
      ]
    },
    {
      "collectionGroup": "public_workouts",
      "queryScope": "COLLECTION",
      "fields": [
        {
          "fieldPath": "workout_data.tags",
          "arrayConfig": "CONTAINS"
        },
        {
          "fieldPath": "created_at",
          "order": "DESCENDING"
        }
      ]
    }
  ],
  "fieldOverrides": []
}
```

**Deploy indexes:**
```bash
firebase deploy --only firestore:indexes
```

---

## Step 6: Security Rules

**Add to Firebase Console** ‚Üí Firestore Database ‚Üí Rules:

```javascript
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    
    // Existing rules for users collection...
    
    // PUBLIC WORKOUTS - Anyone can read, only creator can write
    match /public_workouts/{workoutId} {
      // Anyone can read public workouts
      allow read: if true;
      
      // Only authenticated users can create
      allow create: if request.auth != null 
                    && request.resource.data.creator_id == request.auth.uid;
      
      // Only creator can update/delete
      allow update, delete: if request.auth != null 
                            && resource.data.creator_id == request.auth.uid;
    }
    
    // PRIVATE SHARES - Anyone with token can read
    match /private_shares/{shareToken} {
      // Anyone can read (token acts as authentication)
      allow read: if true;
      
      // Only authenticated users can create
      allow create: if request.auth != null 
                    && request.resource.data.creator_id == request.auth.uid;
      
      // Only creator can delete
      allow delete: if request.auth != null 
                    && resource.data.creator_id == request.auth.uid;
    }
  }
}
```

---

## Step 7: Testing Checklist

### Manual Testing Steps

- [ ] **Share workout publicly**
  - [ ] With creator name shown
  - [ ] Anonymous (no creator name)
  - [ ] Verify duplicate prevention (can't share same workout twice)

- [ ] **Browse public workouts**
  - [ ] Default sort (created_at)
  - [ ] Sort by view_count
  - [ ] Sort by save_count
  - [ ] Filter by tags
  - [ ] Pagination works

- [ ] **View public workout**
  - [ ] View count increments
  - [ ] All workout data present

- [ ] **Save public workout**
  - [ ] Saves to user's library
  - [ ] Save count increments
  - [ ] Custom name works
  - [ ] Default "(Shared)" suffix added

- [ ] **Share workout privately**
  - [ ] Token generated
  - [ ] Share URL returned
  - [ ] With expiration
  - [ ] Without expiration

- [ ] **View private share**
  - [ ] Valid token works
  - [ ] View count increments
  - [ ] Expired share rejected

- [ ] **Save private share**
  - [ ] Saves to user's library
  - [ ] Custom name works

- [ ] **Delete private share**
  - [ ] Creator can delete
  - [ ] Non-creator cannot delete

- [ ] **Security rules**
  - [ ] Unauthenticated can read public workouts
  - [ ] Unauthenticated cannot create shares
  - [ ] Users can only modify their own shares

- [ ] **Indexes**
  - [ ] All queries work without errors
  - [ ] Performance is acceptable

---

## üéØ Success Criteria

Phase 1 is complete when:

1. ‚úÖ All files created and integrated
2. ‚úÖ Security rules deployed
3. ‚úÖ Indexes deployed
4. ‚úÖ All API endpoints functional
5. ‚úÖ Manual testing checklist passed
6. ‚úÖ No console errors
7. ‚úÖ Documentation updated

---

## üìù Next Steps (Phase 2 - Frontend)

After Phase 1 is complete:

1. Create sharing UI components
2. Add share buttons to workout builder
3. Create public workout browse page
4. Implement share link handling
5. Add save workout functionality

---

## üîó Related Documents

- [`WORKOUT_SHARING_ARCHITECTURE_ANALYSIS.md`](WORKOUT_SHARING_ARCHITECTURE_ANALYSIS.md) - Architecture decisions
- [`backend/scripts/firestore_workout_analysis.json`](backend/scripts/firestore_workout_analysis.json) - Database structure
- [`WORKOUT_SHARING_SERVICE_IMPLEMENTATION.md`](WORKOUT_SHARING_SERVICE_IMPLEMENTATION.md) - Complete service code

---

**Ready to implement? Switch to Code mode and start with Step 1!**